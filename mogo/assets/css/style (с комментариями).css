/* font-family: 'Kaushan Script', cursive;

font-family: 'Montserrat', sans-serif;

font-family: 'Roboto', sans-serif; */

body {
  /* Задаем общие параметры, схожие у многих блоков (Определили по макету). Задаём общие шрифт, размеры, текст и отступы между строками шрифта. Также убираем стандартный отступ. */

  margin: 0;
  font-family: 'Montserrat', sans-serif;
  font-size: 15px;
  color: #333;
  line-height: 1.6;
}

*,
*:before,
*:after {
  /* http://htmlbook.ru/css/box-sizing */

  box-sizing: border-box;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  /* Убираем стандартные отступы у заголовков */

  margin: 0;
}

/* Container */

.container {
  /* Этот класс определяет боковые рамки контента */

  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* Intro */

.intro {
  /* Область действия - весь экран (100% по горизонтали и 100vh в высоту). Фон - картинка (просто url в background, всё просто. center no-repeat говорят растелить пикчу по центру и чтоб без повоторений. size говорит в случае чего растянуть пикчу на размер всего экрана. Так и получаем то, что есть (красиво). */

  width: 100%;
  height: 100vh;

  background: url('../images/intro.jpg') center no-repeat;
  background-size: cover;

  display: flex;
  flex-direction: column;
  justify-content: center;
}

.intro__inner {
  /* Засунули надписи в отдельный блок, ибо в макете они переносятся. По-другому это сделать никак, а лепить какой-нибудь \n не катит. Ну и всё. Запихнули в блок. Макс ширина 880пкс, блок по центру, текст тоже (а значит во всех вложенных в иннер блоках это свойства можно убрать, чтоб не дублировать). */

  text-align: center;

  width: 100%;
  max-width: 880px;
  margin: 0 auto;
}

.intro__title {
  /* Просто текст. */

  font-size: 150px;
  font-weight: 700;
  color: #fff;
  text-transform: uppercase;
  line-height: 1;
}

.intro__title:after {
  /* Полоска афтер после тайтла. Её мы абсолютно не позиционируем, как с навбаром в хедере, потому что здесь ширина не совпадает. Мы просто её стилизируем, как *почти* независсимый блок. Своя ширина, своя высота, топ = размеров блока тайтла. Ну и отступы от тайтла и кнопки ниже. */

  content: '';
  display: block;
  background-color: #fff;
  width: 60px;
  height: 3px;
  top: 100%;
  margin: 60px auto;
}

.intro__suptitle {
  /* Просто текст. */

  margin-bottom: 20px;

  font-size: 72px;
  color: #fff;
  font-family: 'Kaushan Script', cursive;
}

/* Header */

.header {
  /* Этот блок не находится в какой-то секции, а существует отдельно, но тем не менее его видно на Интро. Это из-за абсолюта. Хедер просто "лег" поверх Интро. Также область действия - весь экран (100%), - и плотно прижат к верху (top, left, right по 0). z-index говорит лечь ПОВЕРХ всего. +отступ сверху */

  padding-top: 30px;
  width: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
}

.header__inner {
  /* В этом блоке ещё два - лого и навигация. Чтоб разбить их по разным углам, достаточно применить флекс, и justify-content на space-between. Ну и в одну линию их выровнять алигном. */

  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header__logo {
  /* Всё просто - логотип принимает значения размера шрифта в пикслях, жирность (700) и цвет. */

  font-size: 30px;
  font-weight: 700;
  color: #fff;
}

/* Nav */

.nav {
  /* Задает для всех размера текста внутри блока с таким классом и говорит, чтоб все было заглавными буквами. Цвет текста мы здесь задать не можем. */

  font-size: 14px;
  text-transform: uppercase;
}

.nav__link {
  /* Сначала задаем, что этот блок имеет встроенно-блочную структуру. Т.е. он как бы всроен внутри строки, но и ведет себя как блок (т.е. принимает значения ширины и высоты (ибо обычные строчные не принимают, а обычные блочные переносят блок на следующую строку)). И прижимает к верху (выравнивает верхнюю границу этого элемента с верхней границей родителя). Потом задаем цвет отступы, убираем декор ссылки и говорим, что анимация на смену значения color будет плавной длиной в .2 секунды. Для этого нужно предварительно в псевдоэлементе :hover этого элемента задать другой цвет на color. */

  display: inline-block;
  vertical-align: top;

  position: relative;

  color: #fff;
  text-decoration: none;
  margin: 0 15px;

  transition: color 0.1s linear;
}

.nav__link:after {
  /* В псевдоэлементе after мы создаем полоску после элемента меню. content: ''; display: block; самые главные вещи. Потом всё просто, ширина на 100% этого маленького подблока, высота какая надо и фон (не текста, а блока).Также позиционирование абсолютное (видим, что в обычном линке оно относительное). Т.е. теперь афтер приварен к своему родителю. 
  
  Чтоб плавно появлять эту полоску можем юзнуть транзишн, но он должен касаться какого-то конкретного свойства. Хитрим: задаем начальному афтеру (этому) прозрачность 0, а в ховер:афтере меняем на 1. Здесь же прописываем плавность для смены опасити.
  
  Касательно топ 100%. Процентаж берется от размера блока нав__линка целиком. Т.е. полоска расположена на расстоянии 1 нав__линка от верха. То же самое с лефтом. Мы просто прибиваем полоску намертво куда надо. Индекс кладет поверх всех.*/

  content: '';
  display: block;
  width: 100%;
  height: 3px;
  background-color: #fce38a;

  opacity: 0;

  position: absolute;

  top: 100%;
  left: 0;
  z-index: 1;

  transition: opacity 0.1s linear;
}

.nav__link:hover {
  /* При наведении на один из элементов, поменять цвет. В родительском селекторе записана длина анимации в свойстве transition: <параметр> <продолжительность> <метод>; */

  color: #fce38a;
}

.nav__link:hover:after,
.nav__link.active:hover {
  /* При наведении, непрозрачность = 1. Транзишн анимацию прописали в самом афтере. */

  opacity: 1;
}

.nav__link.active {
  /* Просто актив нав__линка. */

  color: #fce38a;
}

/* Button */

.btn {
  /* Это кнопка. Дисплей такой, чтоб её было удобно позиционировать. vertical-align: top прибивает её к верхнему краю (себя?). Паддиги, границы, шрифт, цвет и тд понятно, а цвет фона - пустой, ибо при ховере он заполнится цветом, а в транзишн обязательно нужно передать какой-нибудь свойство (передаем два кста - цвет шрифта и фон (с параметром цвета внутри)).  */

  display: inline-block;
  vertical-align: top;
  padding: 8px 30px;

  border: 3px solid #fff;

  font-size: 14px;
  font-weight: 700;
  color: #fff;
  text-transform: uppercase;
  text-decoration: none;
  background-color: none;

  transition: background 0.1s linear, color 0.1s linear;
}

.btn:hover {
  /* Собсна ховер. */

  background-color: #fff;
  color: #333;
}

/* Slider */

.slider {
  /* Обвертка лишь для того, чтобы взять весь слайдер целиком с контейнером и прибить к низу. Позиционируем абсолютно. Дно 0. Но если только так, то начало слайдера будет торчать в центре. Поэтому так же и Лево 0. Ширина 100% естественно. */

  width: 100%;

  position: absolute;
  bottom: 0;
  left: 0;
  z-index: 1;
}

.slider__inner {
  /* Получаеца блок с 4 подблоками, которые нужно разместить по горизонтали в пределах всего контейнера - флекс. Отступ сверху от кнопки. */

  display: flex;
  justify-content: space-between;
  margin-top: 30px;
}

.slider__item {
  /* Каждый флексовый элемент слайдера имеет ширину в процентах (удобно при масштабировании), паддинг ввех (чтоб бордер потом нормально задать), собсна бордер (крыша), шрифт, цвет, прозрачность .7 по макету. Позишн релатив, потому что зададим псевдоэлемент before, размеры которого будут зависеть от итема напрямую. */

  width: 23%;
  padding: 20px 0;
  position: relative;

  border-top: 3px solid #fff;
  opacity: 0.7;

  font-size: 18px;
  color: #fff;
  text-transform: uppercase;
}

.slider__item.active {
  /* Активный итем непрозрачен. */

  opacity: 1;
}

.slider__item.active:before {
  /* Собсна before. Размеры, фон, расположение. Топ -3пкс, чтоб совпал с бордером. */

  content: '';
  display: block;
  width: 70px;
  height: 3px;

  background-color: #f38181;

  position: absolute;
  top: -3px;
  left: 0;
  z-index: 1;
}

.slider__num {
  /* Цифра в спане. */

  font-size: 24px;
  font-weight: 700;
}
