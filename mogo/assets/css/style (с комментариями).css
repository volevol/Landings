/* font-family: 'Kaushan Script', cursive;

font-family: 'Montserrat', sans-serif;

font-family: 'Roboto', sans-serif; */

body {
  /* Задаем общие параметры, схожие у многих блоков (Определили по макету). Задаём общие шрифт, размеры, текст и отступы между строками шрифта. Также убираем стандартный отступ. */

  margin: 0;
  font-family: 'Montserrat', sans-serif;
  font-size: 15px;
  color: #333;
  line-height: 1.6;
}

*,
*:before,
*:after {
  /* http://htmlbook.ru/css/box-sizing */

  box-sizing: border-box;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  /* Убираем стандартные отступы у заголовков */

  margin: 0;
}

/* Container */

.container {
  /* Этот класс определяет боковые рамки контента */

  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* Intro */

.intro {
  /* Область действия - весь экран (100% по горизонтали и 100vh в высоту). Фон - картинка (просто url в background, всё просто. center no-repeat говорят растелить пикчу по центру и чтоб без повоторений. size говорит в случае чего растянуть пикчу на размер всего экрана. Так и получаем то, что есть (красиво). */

  width: 100%;
  height: 100vh;

  background: url('../images/intro.jpg') center no-repeat;
  background-size: cover;

  display: flex;
  flex-direction: column;
  justify-content: center;
}

.intro__inner {
  /* Засунули надписи в отдельный блок, ибо в макете они переносятся. По-другому это сделать никак, а лепить какой-нибудь \n не катит. Ну и всё. Запихнули в блок. Макс ширина 880пкс, блок по центру, текст тоже (а значит во всех вложенных в иннер блоках это свойства можно убрать, чтоб не дублировать). */

  text-align: center;

  width: 100%;
  max-width: 880px;
  margin: 0 auto;
}

.intro__title {
  /* Просто текст. */

  font-size: 150px;
  font-weight: 700;
  color: #fff;
  text-transform: uppercase;
  line-height: 1;
}

.intro__title:after {
  /* Полоска афтер после тайтла. Её мы абсолютно не позиционируем, как с навбаром в хедере, потому что здесь ширина не совпадает. Мы просто её стилизируем, как *почти* независсимый блок. Своя ширина, своя высота, топ = размеров блока тайтла. Ну и отступы от тайтла и кнопки ниже. */

  content: '';
  display: block;
  background-color: #fff;
  width: 60px;
  height: 3px;
  top: 100%;
  margin: 60px auto;
}

.intro__suptitle {
  /* Просто текст. */

  margin-bottom: 20px;

  font-size: 72px;
  color: #fff;
  font-family: 'Kaushan Script', cursive;
}

/* Header */

.header {
  /* Этот блок не находится в какой-то секции, а существует отдельно, но тем не менее его видно на Интро. Это из-за абсолюта. Хедер просто "лег" поверх Интро. Также область действия - весь экран (100%), - и плотно прижат к верху (top, left, right по 0). z-index говорит лечь ПОВЕРХ всего. +отступ сверху */

  padding-top: 30px;
  width: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
}

.header__inner {
  /* В этом блоке ещё два - лого и навигация. Чтоб разбить их по разным углам, достаточно применить флекс, и justify-content на space-between. Ну и в одну линию их выровнять алигном. */

  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header__logo {
  /* Всё просто - логотип принимает значения размера шрифта в пикслях, жирность (700) и цвет. */

  font-size: 30px;
  font-weight: 700;
  color: #fff;
}

/* Nav */

.nav {
  /* Задает для всех размера текста внутри блока с таким классом и говорит, чтоб все было заглавными буквами. Цвет текста мы здесь задать не можем. */

  font-size: 14px;
  text-transform: uppercase;
}

.nav__link {
  /* Сначала задаем, что этот блок имеет встроенно-блочную структуру. Т.е. он как бы всроен внутри строки, но и ведет себя как блок (т.е. принимает значения ширины и высоты (ибо обычные строчные не принимают, а обычные блочные переносят блок на следующую строку)). И прижимает к верху (выравнивает верхнюю границу этого элемента с верхней границей родителя). Потом задаем цвет отступы, убираем декор ссылки и говорим, что анимация на смену значения color будет плавной длиной в .2 секунды. Для этого нужно предварительно в псевдоэлементе :hover этого элемента задать другой цвет на color. */

  display: inline-block;
  vertical-align: top;

  position: relative;

  color: #fff;
  text-decoration: none;
  margin: 0 15px;

  transition: color 0.1s linear;
}

.nav__link:after {
  /* В псевдоэлементе after мы создаем полоску после элемента меню. content: ''; display: block; самые главные вещи. Потом всё просто, ширина на 100% этого маленького подблока, высота какая надо и фон (не текста, а блока).Также позиционирование абсолютное (видим, что в обычном линке оно относительное). Т.е. теперь афтер приварен к своему родителю. 
  
  Чтоб плавно появлять эту полоску можем юзнуть транзишн, но он должен касаться какого-то конкретного свойства. Хитрим: задаем начальному афтеру (этому) прозрачность 0, а в ховер:афтере меняем на 1. Здесь же прописываем плавность для смены опасити.
  
  Касательно топ 100%. Процентаж берется от размера блока нав__линка целиком. Т.е. полоска расположена на расстоянии 1 нав__линка от верха. То же самое с лефтом. Мы просто прибиваем полоску намертво куда надо. Индекс кладет поверх всех.*/

  content: '';
  display: block;
  width: 100%;
  height: 3px;
  background-color: #fce38a;

  opacity: 0;

  position: absolute;

  top: 100%;
  left: 0;
  z-index: 1;

  transition: opacity 0.1s linear;
}

.nav__link:hover {
  /* При наведении на один из элементов, поменять цвет. В родительском селекторе записана длина анимации в свойстве transition: <параметр> <продолжительность> <метод>; */

  color: #fce38a;
}

.nav__link:hover:after,
.nav__link.active:hover {
  /* При наведении, непрозрачность = 1. Транзишн анимацию прописали в самом афтере. */

  opacity: 1;
}

.nav__link.active {
  /* Просто актив нав__линка. */

  color: #fce38a;
}

/* Button */

.btn {
  /* Это кнопка. Дисплей такой, чтоб её было удобно позиционировать. vertical-align: top прибивает её к верхнему краю (себя?). Паддиги, границы, шрифт, цвет и тд понятно, а цвет фона - пустой, ибо при ховере он заполнится цветом, а в транзишн обязательно нужно передать какой-нибудь свойство (передаем два кста - цвет шрифта и фон (с параметром цвета внутри)).  */

  display: inline-block;
  vertical-align: top;
  padding: 8px 30px;

  border: 3px solid #fff;

  font-size: 14px;
  font-weight: 700;
  color: #fff;
  text-transform: uppercase;
  text-decoration: none;
  background-color: none;

  transition: background 0.1s linear, color 0.1s linear;
}

.btn:hover {
  /* Собсна ховер. */

  background-color: #fff;
  color: #333;
}

/* Slider */

.slider {
  /* Обвертка лишь для того, чтобы взять весь слайдер целиком с контейнером и прибить к низу. Позиционируем абсолютно. Дно 0. Но если только так, то начало слайдера будет торчать в центре. Поэтому так же и Лево 0. Ширина 100% естественно. */

  width: 100%;

  position: absolute;
  bottom: 0;
  left: 0;
  z-index: 1;
}

.slider__inner {
  /* Получаеца блок с 4 подблоками, которые нужно разместить по горизонтали в пределах всего контейнера - флекс. Отступ сверху от кнопки. */

  display: flex;
  justify-content: space-between;
  margin-top: 30px;
}

.slider__item {
  /* Каждый флексовый элемент слайдера имеет ширину в процентах (удобно при масштабировании), паддинг ввех (чтоб бордер потом нормально задать), собсна бордер (крыша), шрифт, цвет, прозрачность .7 по макету. Позишн релатив, потому что зададим псевдоэлемент before, размеры которого будут зависеть от итема напрямую. */

  width: 23%;
  padding: 20px 0;
  position: relative;

  border-top: 3px solid #fff;
  opacity: 0.7;

  font-size: 18px;
  color: #fff;
  text-transform: uppercase;
}

.slider__item.active {
  /* Активный итем непрозрачен. */

  opacity: 1;
}

.slider__item.active:before {
  /* Собсна before. Размеры, фон, расположение. Топ -3пкс, чтоб совпал с бордером. */

  content: '';
  display: block;
  width: 70px;
  height: 3px;

  background-color: #f38181;

  position: absolute;
  top: -3px;
  left: 0;
  z-index: 1;
}

.slider__num {
  /* Цифра в спане. */

  font-size: 24px;
  font-weight: 700;
}

/* Section */

.section {
  /* Каждая такая блок-тема будет в отдельной секции. Но они все очень похожи, поэтому мы будем переиспользовать разметку хтмл  и их классы. Сам тег вроде чисто семантический, отличий от дива нету. */

  padding: 80px 0;
}

.section--devices {
  /* Просто задает фон на секцию с девайсами. */

  background: url(/assets/images/design/bg.jpg) no-repeat center;
  background-size: cover;
  padding-bottom: 0;
}

.section__header {
  /* Это обвертка шапки секции, которая часто повторяется + нужно отцентровать текст немного по-другому нежели это делает контейнер. Отступы, текст по центру. */

  width: 100%;
  max-width: 950px;
  margin: 0px auto 50px;

  text-align: center;
}

.section__suptitle {
  /* Просто блок с текстом. */

  font-family: 'Kaushan Script', cursive;
  font-size: 24px;
  color: #333;
}

.section__title {
  /* Просто блок с текстом. */

  font-size: 30px;
  font-weight: 700;
  color: #333;
  text-transform: uppercase;
}

.section__title:after {
  /* Полоска после тайтла. Отступы можно оказывается задавать прямо здесь марджином. Псевдоэлемент афтер ведет себя в данном случае как полноценный блок. */

  content: '';
  display: block;
  width: 60px;
  height: 3px;
  margin: 30px auto;

  background-color: #f38181;
}

.section__text {
  /* Просто блок с текстом. */

  font-size: 15px;
  color: #999;
}

/* About */

.about {
  /* Флексовая обертка для картинок. Отступ. */

  margin-top: 80px;
  display: flex;
  justify-content: space-between;
}

.about__item {
  /* Это класс итема флексов, внутри которого ещё лежит картинка с текстом. По факту этот оже обертка. Позишн релатив для того, чтоб текст лег поверх пикчи. Бг колор это "тень", когда пикча улетит влево-вверх при ховере. */

  position: relative;
  width: 380px;

  background-color: #95e1d3;
}

.about__item:hover .about__img {
  /* При ховере на весь итем блок с картинкой улетает влево-вверх. Я изначально ставил ховеры непосредственно на пикчу или текст, но случались от того проблемы с областями видимости курсора на элементах, типа того. Крч лучше ховер ставить на обертывающий элемент, и от него уже тянуть ниточки что-куда анимируеся. */

  transform: translate3d(-10px, -10px, 0);
}

.about__item:hover .about__img img {
  /* При ховере на весь итем сама картинка становится прозрачной, чтоб градиент, который установлен как бг фон для блока картинки стал виден. */

  opacity: 0.1;
}

.about__item:hover .about__text {
  /* При ховере на весь итем текст становится непрозрачным. Ну т.е. появляется, ибо изначально он скрыт опасити на 0. */

  opacity: 1;
}

.about__img {
  /* Это класс блока с картинкой. Блок имеет градиент, который проявляется при опасити имг на 10%. Транзишн на трансформ, ибо при ховере итема, двигается именно блок с пикчей, а не сама пикча. Так что транзишн нужен именно здесь. */

  background: linear-gradient(#f38181, #fce38a);
  transition: transform 0.2s linear;
}

.about__img img {
  /* Собсно сама картинка. Дисплей блок здесь идет вместе с шириной 380пкс указаной в итеме. Я не знаю как это работает, но дисплей блок делает так, что бг фон итема не выглядывает из-за картинки. "Заправляет ему рубашку" грубо говоря. Ну и транзишн на опасити. */

  display: block;

  transition: opacity 0.1s linear;
}

.about__text {
  /* Текст поверх картинки. Шрифт, цвет, индекс, транзишн, опасити, всё такое. А теперь об отцентрировании. Значит сначала позишн абсолют, при релятивном итеме. Лефт 0 просто для галочки (прижимает по идее к левому борту, убирает лишние отступы вроде). Топ 50% понятно. Также текст-алигн: центр, но без ширины 100% работать не будет. И последнее transform: translate3d(0, -50%, 0) он подтягивает блок с текстом вверх на 50% своей высоты. Я гребу, почему оно изначально криво, и как вообще можно было додуматься влепить сюда вот это, что оно теперь работает пиксель в пиксель, но оно работает, и нужно запомнить как. */

  width: 100%;

  font-size: 18px;
  color: #fff;
  text-transform: uppercase;
  font-weight: 700;
  text-align: center;
  opacity: 0;

  position: absolute;
  top: 50%;
  left: 0;
  z-index: 2;
  transform: translate3d(0, -50%, 0);

  transition: opacity 0.2s linear;
}

/* Statistics */

.statistics {
  /* Обвертка ради цвета фона. Секция здесь не подходит, потому что у неё должен быть заголовок. Семантика ломается. Потому лучше див.  */

  background-color: #95e1d3;
}

.stat {
  /* Ну это просто ради флекса класс, и всё. */

  display: flex;
}

.stat__item {
  /* Флекс 1 1 0 делает все элементы одинакового размера заполнеными по всему периметру. Паддинг, боордер, центр, цвет понятно. */

  flex: 1 1 0;
  padding: 70px 25px;

  border-left: 1px solid #b5eae0;

  text-align: center;
  color: #fff;
}

.stat__item:last-child {
  /* Задает границу последнему элементу, чтоб красиво было. */

  border-left: 1px solid #b5eae0;
}

.stat__count {
  /* Стилизируем число (текст). */

  margin-bottom: 10px;

  font-size: 72px;
  font-weight: 700;
  line-height: 1;
}

.stat__text {
  /* Просто блок с текстом. */

  font-size: 14px;
  text-transform: uppercase;
}

/* Services */

.services {
  /* Будет 2 по 3 блока флексов. */

  display: flex;
}

.services__item {
  /* Все итемы одинакового размера. Отступы как на макете. Позишн релятив, чтоб иконку задать нормально. */

  flex: 1 1 0;
  padding: 0 30px 0 90px;
  position: relative;
}

.services__icon {
  /* Собственно иконка с позишн абсолют и отступами. */

  position: absolute;
  top: 0;
  left: 30px;
  z-index: 1;
}

.services__title {
  /* Просто блок с текстом. */

  margin-bottom: 10px;

  font-size: 14px;
  color: #333;
  text-transform: uppercase;
}

.services__text {
  /* Просто блок с текстом. */

  font-size: 15px;
  color: #999;
  font-family: 'Roboto', sans-serif;
}

/* Devices */

.devices {
  /* Этот блок содержит 2 пикчи. Нужен он для того, чтобы при масштабировании по-хитрому расположенные с помощью отступом картинки не уполетали друг от друга, а двигался только этот блок. Релятивен кста. Т.е. сами пикчи будут абсолютами. */

  width: 100%;
  max-width: 620px;
  margin: 0 auto;

  position: relative;
}

.devices__item {
  /* И без этого норм работает, но пусть будет. */

  display: block;
}

.devices__item--ipad {
  /* Айпад с отступом. */
  padding-left: 5%;
}

.devices__item--iphone {
  /* Айфон с отступом. Абсолютный кста только айфон. Я не знаю почему, но если задать абсолют на айпад, то пикчи разлетятся в разные стороны. */

  position: absolute;
  right: -10%;
  bottom: -15%;
}
